# Морфология 3
В этом семинаре нам придется познакомится с морфологическим синтезом на примере FOMA - компилятора для конечных преобразований.

Их сайт: https://fomafst.github.io/

## Getting started
Для начала разберем туториал с их сайта.
### Установка:
Для установки на Debian/Ubuntu можно воспользоваться командой
~~~
apt instal foma
~~~ 
Для Windows и Mac качаем бинарники с их сайта.

### Базовые команды
Для задания регулярного выражения используется команда: `regex REGULAR-EXPRESSION ;`
Также можно давать имена выражениям для последующего использования: `def NAME REGEX ;` 
А для того, чтобы вывести все слова реализуемые текущим автоматом существует команда `words`
Пример:
```
> def char a|b ;
> regex char char ;
> words
aa
ab
ba
bb
``` 
Также, если установлен *GraphViz*, то можно нарисовать граф текущего автомата с помощью команды `view`. 
Однако это работает только на UNIX-подобных системах. По крайней мере можно использовать команду `net`, 
которая выведет ASCII листинг:
```
> net
Sigma: a b
Size 2.
Net: 234E2BE34
Flags: deterministic pruned minimized epsilon_free loop_free
Arity: 1
Ss0: a -> s1, b -> s1.
s1: a -> fs2, b -> fs2.
fs2: (no arcs).
```  
Помимо конечных автоматов можно использовать конечные преобразователи.
 Регулярные выражения задаются с добавлением знака `:`, означающего, что куда преобразовывать.
 Чтобы вывести всевозможные пары вход-выход используется команда `pairs`, а чтобы преобразовать слово используется 
команда `down` или `up` для преобразования в обратную сторону. Пример:
```
> regex a:b b:a ;
> pairs 
ab ba
> down 
down> ab
ba
> up 
up> ba
ab
``` 

### Синтаксис
Местный синтаксис немного отличается от такого в том же питоновском `re`. Перечислим главные отличия:
- Все ругулярные выражения заканчиваются на `;`
- Для грппировки используются квадратные скобки и нет символьных классов типа `[A-Z]`. Перечислять символы придется ручками.
- Опциональные элементы указываются в круглых скобках: `a b (c)` даст два слова `ab` и `abc`.
- "Любой символ" представлен знаком вопроса, а не точкой
- Помимо объединения `|` также есть пересечение `&` и дополнинние `~`. Например, для задания слов, начинающихся и заканчивающихся
на `a`, можно использовать выражение `a ?* & ?* a`
- Спец символы помещаются в кавычки или пере ними ставится знак `%`: `"_"` или `%_` 
- Символы для описания преобразователей: `:`, `.o.` и `->` 
- Пустой символ представляется как `0`  
- Одиночные символы разделяются пробелом, слова же могут использоваться для переменных.

### Преобразователи
С преобразователями мы уже немного познакомились: можно добавлять знак `:` в регулярное выражение для замены. 
Но возможно это не лучший синтаксис. Для моделирования морфологии часто используются так нызываемые rewrite rules:
```
LHS -> RHS || LC _ RC
``` 
где `LHS` - левая сторона (что преобразуется), `RHS` - правая сторона (во что преобразуется),
 `LC` - левый контекст, `RC` - правый контекст.
Например, регулярное выражение
```
regex a -> b || c _ d
```
заменит все `a` на `b` только между `c` и `d`. Левый и правый контексты могут быть опциональными. 
Также можно использовать спец символ `.#.` для обозначения краев слов. Для вставки "из ничего" (когда `LHS` пустой) используется 
символ `[..]`. Еще можно объединять преобразователи с помощью знака композиции `.0.`. Например:
```
> regex a -> b .o. b -> c ;
> down
down> abc
ccc 
```

### Задание 1
Написать преобразователь, который ставит слова `cat` и `bus` в единственное и 
множественное число.
```
cat[Sg] -> cat
bus[Sg] -> bus
cat[Pl] -> cats
bus[Pl] -> buses
```
Подсказки можно найти в упражнении 3 в туториале:
  https://github.com/mhulden/foma/blob/master/foma/docs/simpleintro.md

### Грамматики

Преобразователи также можно задавать в виде контекстно-свободных грамматик.
 Грамматику удобно задать в отдельном файле с расширением `*.lexc`. 
В качестве примера разберем как можно задать первую часть `Lexicon` из упражнения. 
Для начала можно задать элементы, состоящих из нескольких символов.
```
Multichar_Symbols +Sg +Pl
```

Затем  нужно обязательно задать корневой элемент и куда он может переходить:
```
LEXICON ROOT

Noun ;
```
Далее все элементы задаются в виде
```
LEXICON State

LHS1(:RHS1) NewState1;
LHS2(:RHS2) NewState2;
...
LHSn(:RHSn) NewStateN;
```

Для нашего примера это будет выглядеть так:
```
LEXICON Noun
cat Ninf;
bus Ninf;

LEXICON Ninf
+Sg:0 #;
+Pl:^s #;
```

Далее мы можем загрузить в интерпретатор грамматику и задать ей имя:
```
read lexc lexicon.lexc
define Lexicon;
```
А дальше делать композицию с другими преобразователями как и раньше.

Скрипты можно сохранять с расширением `*.foma` и загружать с помощью команды
```
source grammar.foma
```

### Задание 2
Написать преобразователь для синтеза существительных множественного числа как в презентации.
*Туториал по морфологии в FOMA: https://fomafst.github.io/morphtut.html*
### Задание 3*
Написать преобразователь для синтеза в арабской морфологии.
